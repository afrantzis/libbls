\usemodule[title]

\setuptitle
  [title={Libbless User Guide},
   author={Alexandros Frantzis, Michael Iatrou},
   date={}]

\setupwhitespace[medium]

\starttext

\placetitle
\completecontent

\section{Introduction}

Libbless is a library providing services useful to applications handling large
amount of binary data.

Libbless origins are traced back to the Bless hex editor project. The author of
Bless (which is one of the main authors of libbless, too) saw that many of the
services used in the project could be useful to other applications. The only
problem was that Bless was written in C\#/Mono so the code could not be readily
shared by others. Furthermore, the code, having been through years of changes
was not as clean and elegant as the author wanted. The decision was made to
create the libbless project in a more neutral language. The idea was to create
a library that would be powerful enough to serve as a back-end to Bless but
still decoupled enough so that it could be used by a variety of non-GUI and
GUI applications, too.

The purpose of this text is to describe how to use the libbless library in your
application. It's not supposed to be a complete API reference but rather a
high level overview of the API.

\section{Libbless modules}

The services of libbless are split into independent modules. An application may
choose to use any number of the provided modules. 

The modules currently provided by libbless are:
\startitemize
\item Buffer module
\stopitemize

To handle namespace pollution, all function and data structures belonging to a
module are prepended with \type{bless_{module-name}}. For example the save
function in the buffer module is \type{bless_buffer_save()}.

\subsection{General considerations}

Libbless was intentionally written not to be thread-safe or reentrant-safe.
This decision was made so that the core library could be as simple and
efficient as possible and also not to impose a pre-defined concurrency model
on the library user. However, the API has been designed so that it is possible
to be used in a thread-safe manner, with some extra effort, ofcourse.

The module documentation that follows gives some ideas on how to use libbless
in a complicated environment.

\subsection{Buffer module}

The buffer module is the main module in the libbless library. It provides
functions to access and edit files of arbitrary size (limited only by the OS
and filesystem) in an efficient manner.

The main data structure of the module is the \type{bless_buffer_t} opaque type.
User code can only use pointers to \type{bless_buffer_t} and cannot access its
members directly.

The functions in the module can be logically seperated into the following
operation categories:

\startitemize
\item File operations
\item Edit operations
\item Undo operations
\item Info operations
\stopitemize

\subsubsection{Using buffers in a concurrent enviroment}

As noted before, the buffer module is neither thread- nor reentrant-safe. To
use it in a concurrent environment some sort of locking or ordering must be
used. The implementation of the concurrency mechanism is left to the user of
the library.

In the simplest case a single lock can be used to control access to the whole 
module. Then the user must acquire the lock before performing any access to the
buffer. This can be extended to use a reader-writer lock or even a triple lock
like this one: (TODO: reevaluate this scheme RFC mgi?)

\placetable{Triple lock scheme}
\starttable[|c|c|c|c|c|]
\NC      \NC       \NC \THREE Request \FR
\NC      \NC       \NC Read \NC Write \NC File \MR
\NC      \NC Read  \NC Yes  \NC No    \NC Yes  \MR
\NC Held \NC Write \NC No   \NC No    \NC No   \MR
\NC      \NC File  \NC Yes  \NC No    \NC Yes  \LR
\stoptable

The Read and Write locks represent permission to read from and write to the buffer.
The File lock represents permission to change the file the buffer is associated with.
So, for example, when a thread holds the read lock another thread can acquire
another read lock or a file lock.

\stoptext

